---
tags:
  - view
---
```dataviewjs
const ROOT_DIR = '01_data';
const DISPLAY_SIZE = 50;

// カスタム日付範囲の設定 - ここを変更して期間指定
const START_DATE = '2025/06/01'; // 開始日
const END_DATE = '2025/06/30'; // 終了日

const memoizeZeroArg = (fn) => {
    let cached = false;
    let result;
    return () => {
        if (!cached) {
            result = fn();
            cached = true;
        }
        return result;
    };
};

const memoizeOneArg = (fn) => {
    const cache = new Map();
    return (arg) => {
        if (cache.has(arg)) return cache.get(arg);
        const result = fn(arg);
        cache.set(arg, result);
        return result;
    };
};

const formatDateTime = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
};

const createFileLink = (file) => `[[${file.path}|${file.name}]]`;

const getExtension = (file) => file.extension || '';

const extractFileName = (path) => {
    const lastSlash = path.lastIndexOf('/');
    const fileName = lastSlash === -1 ? path : path.slice(lastSlash + 1);
    return fileName.endsWith('.md') ? fileName.slice(0, -3) : fileName;
};

const stringPool = new Map();
const pooledString = (str) => {
    if (stringPool.has(str)) return stringPool.get(str);
    stringPool.set(str, str);
    return str;
};

const createWikiLink = (path, name) => {
    return pooledString(`[[${path}|${extractFileName(name)}]]`);
};

const generateDatePathsForRange = memoizeZeroArg(() => {
    const dateSet = new Set();
    const startDate = new Date(START_DATE);
    const endDate = new Date(END_DATE);

    let currentDate = new Date(startDate);
    while (currentDate <= endDate) {
        const year = currentDate.getFullYear();
        const month = String(currentDate.getMonth() + 1).padStart(2, '0');
        const day = String(currentDate.getDate()).padStart(2, '0');
        const datePath = `${ROOT_DIR}/${year}/${month}/${day}`;
        dateSet.add(datePath);
        currentDate.setDate(currentDate.getDate() + 1);
    }
    return dateSet;
});

const createPathMatcher = memoizeZeroArg(() => {
    const escapedRootDir = ROOT_DIR.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return new RegExp(`^${escapedRootDir}/(\\d{4})/(\\d{2})/(\\d{2})`);
});

const extractPageData = memoizeOneArg((filePath) => {
    const page = dv.page(filePath);
    return {
        page,
        outlinks: page?.file?.outlinks || [],
        tags: page?.file?.tags || []
    };
});

const isMarkdownFile = (file) => file.extension === 'md';

const isTargetFile = (filePath) => filePath.startsWith(ROOT_DIR);

const isFileInDateRange = (filePath, datePaths) => {
    const pattern = createPathMatcher();
    const pathMatch = filePath.match(pattern);

    if (!pathMatch) return false;

    const fileDate = `${ROOT_DIR}/${pathMatch[1]}/${pathMatch[2]}/${pathMatch[3]}`;
    return datePaths.has(fileDate);
};

const processDateRangeFiles = () => {
    const allFiles = app.vault.getFiles();
    const datePaths = generateDatePathsForRange();
    const filesInRange = new Array();
    const backlinkMap = new Map();
    const outlinkMap = new Map();
    const pageDataCache = new Map();
    const seen = new Set();

    for (const file of allFiles) {
        if (!isTargetFile(file.path) || seen.has(file.path)) continue;

        if (isFileInDateRange(file.path, datePaths)) {
            seen.add(file.path);
            filesInRange.push(file);

            if (isMarkdownFile(file)) {
                const pageData = extractPageData(file.path);
                pageDataCache.set(file.path, pageData);

                outlinkMap.set(file.path, pageData.outlinks);
                pageData.outlinks.forEach(outlink => {
                    if (!outlink?.path) return;

                    if (!backlinkMap.has(outlink.path)) {
                        backlinkMap.set(outlink.path, []);
                    }
                    backlinkMap.get(outlink.path).push({
                        path: file.path,
                        name: file.name
                    });
                });
            }
        } else if (isMarkdownFile(file)) {
            const pageData = extractPageData(file.path);

            pageData.outlinks.forEach(outlink => {
                if (!outlink?.path) return;

                if (!backlinkMap.has(outlink.path)) {
                    backlinkMap.set(outlink.path, []);
                }
                backlinkMap.get(outlink.path).push({
                    path: file.path,
                    name: file.name
                });
            });
        }
    }
    filesInRange.sort((a, b) => b.stat.mtime - a.stat.mtime);
    return { filesInRange, backlinkMap, outlinkMap, pageDataCache };
};

const formatLinks = (links) => {
    if (!links?.length) return "";

    const seen = new Set();
    const result = [];

    for (const link of links) {
        if (!link?.path) continue;

        const wikiLink = createWikiLink(link.path, link.name || link.path);
        if (!seen.has(wikiLink)) {
            seen.add(wikiLink);
            result.push(wikiLink);
        }
    }

    return result.join('\n');
};

const getBacklinks = (filePath, backlinkMap) =>
    formatLinks(backlinkMap.get(filePath));

const getOutlinks = (filePath, outlinkMap) => {
    const outlinks = outlinkMap.get(filePath);
    if (!outlinks?.length) return "";

    const seen = new Set();
    const result = [];

    for (const link of outlinks) {
        if (!link?.path) continue;

        const wikiLink = createWikiLink(link.path, link.path);
        if (!seen.has(wikiLink)) {
            seen.add(wikiLink);
            result.push(wikiLink);
        }
    }

    return result.join('\n');
};

const getTags = (file, pageDataCache) => {
    if (!isMarkdownFile(file)) return '';

    const pageData = pageDataCache.get(file.path);
    return pageData?.tags?.length ? pageData.tags.join('\n') : '';
};

const createTableRow = (file, backlinkMap, outlinkMap, pageDataCache) => [
    createFileLink(file),
    getTags(file, pageDataCache),
    getExtension(file),
    getOutlinks(file.path, outlinkMap),
    getBacklinks(file.path, backlinkMap),
    formatDateTime(new Date(file.stat.mtime))
];

const createTableData = (files, backlinkMap, outlinkMap, pageDataCache) =>
    files.map(file => createTableRow(file, backlinkMap, outlinkMap, pageDataCache));

const renderSection = (dv, title, files, tableData) => {
    dv.header(2, title);

    if (!files?.length) {
        dv.paragraph("該当なし");
        return;
    }

    const totalCount = files.length;
    dv.paragraph(`**${totalCount}件** - 更新日時降順`);

    for (let i = 0; i < totalCount; i += DISPLAY_SIZE) {
        const batch = tableData.slice(i, i + DISPLAY_SIZE);
        const batchStart = i + 1;
        const batchEnd = Math.min(i + DISPLAY_SIZE, totalCount);

        dv.paragraph(`**${batchStart}-${batchEnd}件目**`);
        dv.table([
            "ファイル名", "タグ", "拡張子", "リンク先", "被リンク", "更新日時"
        ], batch);
    }
};

const executeDateRangeView = () => {
    try {
        const {
            filesInRange,
            backlinkMap,
            outlinkMap,
            pageDataCache
        } = processDateRangeFiles();

        const tableData = createTableData(filesInRange, backlinkMap, outlinkMap, pageDataCache);
        renderSection(dv, `${START_DATE} ～ ${END_DATE}`, filesInRange, tableData);
    } catch (error) {
        dv.paragraph(`エラーが発生しました: ${error.message}`);
    } finally {
        if (stringPool.size > 0) {
            stringPool.clear();
        }
    }
};

executeDateRangeView();

```
